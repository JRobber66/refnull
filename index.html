<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>refnull Mail</title>
  <style>
    :root { --b:#111; --t:#222; --m:#666; --bd:#e5e5e5; }
    * { box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 24px; color: var(--t); }
    h1 { margin: 0 0 16px; font-size: 20px; }
    .card { border: 1px solid var(--bd); border-radius: 10px; padding: 14px; margin-bottom: 14px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin: 8px 0; }
    input, button, textarea { padding: 10px 12px; border: 1px solid var(--bd); border-radius: 8px; font-size: 14px; }
    input, textarea { flex: 1; min-width: 220px; }
    button { cursor: pointer; background: #fff; }
    button.primary { background: var(--b); color: #fff; border-color: var(--b); }
    ul { list-style: none; padding: 0; margin: 0; }
    li { border-bottom: 1px solid var(--bd); padding: 10px 0; cursor: pointer; }
    li:last-child { border-bottom: none; }
    .muted { color: var(--m); font-size: 12px; }
    .right { margin-left: auto; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    .hidden { display: none !important; }
    pre { white-space: pre-wrap; word-wrap: break-word; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    @media (max-width:600px){ body{margin:12px} }
  </style>
</head>
<body>
  <h1>refnull Mail</h1>

  <div class="card">
    <div class="toolbar">
      <span class="muted">Frontend → GitHub Pages · Backend → Railway · Server → hMail (mail.refnull.net)</span>
      <span class="right muted" id="healthStatus">checking…</span>
    </div>
  </div>

  <div class="card" id="loginCard">
    <h3>Login</h3>
    <form id="loginForm" autocomplete="off">
      <div class="row">
        <input id="username" type="text" placeholder="username or you@refnull.net" required autocomplete="off"/>
        <input id="password" type="password" placeholder="password" required autocomplete="new-password"/>
        <button type="submit" class="primary">Login</button>
      </div>
      <div class="muted">No data is stored locally. A short-lived token cookie is set on sign-in.</div>
    </form>
  </div>

  <div class="card hidden" id="inboxCard">
    <div class="toolbar">
      <strong>Inbox</strong>
      <button id="refreshBtn">Refresh</button>
      <button id="logoutBtn">Logout</button>
      <span id="loginAs" class="right muted"></span>
    </div>
    <ul id="list"></ul>
  </div>

  <div class="card hidden" id="messageCard">
    <div class="toolbar">
      <strong>Message</strong>
      <button id="closeMsgBtn" class="right">Close</button>
    </div>
    <pre id="messagePre" class="mono"></pre>
  </div>

  <div class="card hidden" id="composeCard">
    <h3>Compose</h3>
    <div class="row"><input id="to" placeholder="to@example.com"/></div>
    <div class="row"><input id="subject" placeholder="Subject"/></div>
    <div class="row"><textarea id="body" rows="6" placeholder="Message"></textarea></div>
    <div class="row">
      <button id="sendBtn" class="primary">Send</button>
      <span id="sendStatus" class="muted"></span>
    </div>
  </div>

  <script>
    // HARD-WIRED BACKEND
    const API_BASE = "https://emailserverbackend-production.up.railway.app";

    // --- Minimal cookie helpers (token only) ---
    function setCookie(name, value, minutes) {
      const d = new Date();
      d.setTime(d.getTime() + minutes * 60 * 1000);
      // Note: HttpOnly cannot be set from JS; cookie is JS-accessible.
      document.cookie = `${name}=${encodeURIComponent(value)}; expires=${d.toUTCString()}; path=/; SameSite=Lax; Secure`;
    }
    function getCookie(name) {
      const m = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&') + '=([^;]*)'));
      return m ? decodeURIComponent(m[1]) : null;
    }
    function deleteCookie(name) {
      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/; SameSite=Lax; Secure`;
    }

    const TOKEN_COOKIE = "refnull_token";

    // UI refs
    const sel = (q) => document.querySelector(q);
    const loginCard = sel("#loginCard");
    const inboxCard = sel("#inboxCard");
    const messageCard = sel("#messageCard");
    const composeCard = sel("#composeCard");

    const listEl = sel("#list");
    const messagePre = sel("#messagePre");
    const loginAs = sel("#loginAs");
    const healthStatus = sel("#healthStatus");
    const userInput = sel("#username");
    const passInput = sel("#password");
    const loginForm = sel("#loginForm");

    let token = null;
    let authedUser = null;

    // Health check
    (async function health(){
      try {
        const r = await fetch(`${API_BASE}/api/health`, { cache: "no-store" });
        const j = await r.json();
        healthStatus.textContent = r.ok ? `backend OK · ${j.host}` : "backend unreachable";
      } catch {
        healthStatus.textContent = "backend unreachable";
      }
    })();

    // If token cookie exists, use it immediately
    (async function bootstrapFromCookie() {
      const t = getCookie(TOKEN_COOKIE);
      if (!t) return;
      token = t;
      // We don't know the username without calling something; show UI and let Refresh drive errors.
      loginCard.classList.add("hidden");
      inboxCard.classList.remove("hidden");
      composeCard.classList.remove("hidden");
      loginAs.textContent = `session active`;
      await refreshInbox().catch(() => {
        // If it fails (expired), force logout UX
        doLogoutUI();
      });
    })();

    // Auth (does not store username/pass; sets only token cookie)
    loginForm.addEventListener("submit", async (e) => {
      e.preventDefault();
      try {
        const username = userInput.value.trim();
        const password = passInput.value;
        if (!username || !password) throw new Error("username and password required");

        const r = await fetch(`${API_BASE}/api/login`, {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ username, password })
        });
        const j = await r.json();
        if (!r.ok) throw new Error(j.error || "login failed");

        token = j.token;
        setCookie(TOKEN_COOKIE, token, Math.max(1, Number(j.ttlMinutes || 30))); // minutes
        authedUser = username.includes("@") ? username : `${username}@refnull.net`;

        // Clear password field immediately; do not persist anything else
        passInput.value = "";

        loginCard.classList.add("hidden");
        inboxCard.classList.remove("hidden");
        composeCard.classList.remove("hidden");
        loginAs.textContent = `logged in as ${authedUser}`;

        await refreshInbox();
      } catch (err) {
        alert("Login error: " + err.message);
      }
    });

    // Inbox
    async function refreshInbox() {
      if (!token) throw new Error("no session");
      messageCard.classList.add("hidden");
      listEl.innerHTML = "<li class='muted'>Loading…</li>";
      const r = await fetch(`${API_BASE}/api/messages?limit=25`, {
        headers: { authorization: `Bearer ${token}` }
      });
      const j = await r.json();
      if (!r.ok) {
        if (r.status === 401) {
          alert("Session expired. Please sign in again.");
          doLogoutUI();
          return;
        }
        throw new Error(j.error || "failed to list");
      }
      if (!j.messages.length) {
        listEl.innerHTML = "<li class='muted'>No messages</li>";
        return;
      }
      listEl.innerHTML = "";
      j.messages.forEach(m => {
        const li = document.createElement("li");
        const when = new Date(m.date).toLocaleString();
        li.innerHTML = `<strong>${m.subject || "(no subject)"}</strong><br><span class="muted">${when} — ${m.from || ""}</span>`;
        li.onclick = () => openMessage(m.uid);
        listEl.appendChild(li);
      });
    }

    async function openMessage(uid) {
      if (!token) return;
      const r = await fetch(`${API_BASE}/api/messages/${uid}`, {
        headers: { authorization: `Bearer ${token}` }
      });
      const j = await r.json();
      if (!r.ok) {
        if (r.status === 401) { alert("Session expired."); doLogoutUI(); return; }
        alert(j.error || "failed to fetch message");
        return;
      }
      messagePre.textContent = j.text || "(no body)";
      messageCard.classList.remove("hidden");
      messagePre.scrollIntoView({ behavior: "smooth" });
    }

    sel("#refreshBtn").onclick = refreshInbox;

    function doLogoutUI() {
      deleteCookie(TOKEN_COOKIE);
      token = null; authedUser = null;
      loginCard.classList.remove("hidden");
      inboxCard.classList.add("hidden");
      messageCard.classList.add("hidden");
      composeCard.classList.add("hidden");
    }

    sel("#logoutBtn").onclick = async () => {
      try {
        if (token) {
          await fetch(`${API_BASE}/api/logout`, {
            method: "POST",
            headers: { authorization: `Bearer ${token}` }
          });
        }
      } catch {}
      doLogoutUI();
    };

    // Send
    sel("#sendBtn").onclick = async () => {
      const to = sel("#to").value.trim();
      const subject = sel("#subject").value;
      const text = sel("#body").value;
      const status = sel("#sendStatus");
      if (!token) { status.textContent = "Not signed in."; return; }
      if (!to || !text) { status.textContent = "to and body are required"; return; }
      status.textContent = "Sending…";
      try {
        const r = await fetch(`${API_BASE}/api/send`, {
          method: "POST",
          headers: {
            "content-type": "application/json",
            authorization: `Bearer ${token}`
          },
          body: JSON.stringify({ to, subject, text })
        });
        const j = await r.json();
        if (!r.ok) {
          if (r.status === 401) { status.textContent = "Session expired."; doLogoutUI(); return; }
          throw new Error(j.error || "send failed");
        }
        status.textContent = `Sent · id ${j.messageId}`;
        sel("#to").value = ""; sel("#subject").value = ""; sel("#body").value = "";
        refreshInbox();
      } catch (err) {
        status.textContent = "Error: " + err.message;
      }
    };

    sel("#closeMsgBtn").onclick = () => messageCard.classList.add("hidden");
  </script>
</body>
</html>
